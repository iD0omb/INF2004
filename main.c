#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"
#include "sd_card.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// Button configuration
#define BUTTON_PIN 20
#define DEBOUNCE_DELAY_MS 50

// State machine states
typedef enum {
    BOOT_WAIT_FOR_BUTTON,
    SD_CHECK,
    MAIN_MENU,
    GENERATE_JSON,
    SHOW_SYSTEM_STATUS,
    REBOOT_TOOL,
    QUIT
} State;

// Global state
static bool sd_card_initialized = false;
static bool sd_card_mounted = false;
static State current_state = BOOT_WAIT_FOR_BUTTON;

// ADC configuration
#define ADC_TEMP_CHANNEL 4
#define ADC_VSYS_PIN 29
#define ADC_CONVERSION_FACTOR (3.3f / (1 << 12))
#define ADC_VOLTAGE_DIVIDER 3.0f

// Human-readable formatted content for the log file
static const char generated_json[] = 
"================================================================================\r\n"
"                    SPI FLASH MEMORY CHIP IDENTIFICATION LOG                    \r\n"
"================================================================================\r\n"
"\r\n"
"DEVICE INFORMATION\r\n"
"------------------\r\n"
"Manufacturer ID     : 0xBF (191 decimal)\r\n"
"Manufacturer Name   : SST / Microchip\r\n"
"Memory Type         : 0x26 (38 decimal)\r\n"
"Capacity Code       : 0x41 (65 decimal)\r\n"
"Capacity (bytes)    : 0\r\n"
"\r\n"
"================================================================================\r\n"
"                           SPI COMMAND TEST RESULTS                            \r\n"
"================================================================================\r\n"
"\r\n"
"[1] Read JEDEC ID (Manufacturer/Type/Capacity)\r\n"
"    Command: 0x9F\r\n"
"    Purpose: Retrieves the flash chip's unique identification\r\n"
"    Response Data:\r\n"
"        Byte 0: 0xBF (Manufacturer ID - SST/Microchip)\r\n"
"        Byte 1: 0x26 (Memory Type)\r\n"
"        Byte 2: 0x41 (Capacity Code)\r\n"
"\r\n"
"[2] Read Status Register-1\r\n"
"    Command: 0x05\r\n"
"    Purpose: Reads write protection and busy status\r\n"
"    Response Data:\r\n"
"        Status: 0x00 (Ready, not write-protected)\r\n"
"\r\n"
"[3] Read Status Register-2\r\n"
"    Command: 0x35\r\n"
"    Purpose: Reads additional status flags\r\n"
"    Response Data:\r\n"
"        Status: 0x08\r\n"
"\r\n"
"[4] Read Status Register-3\r\n"
"    Command: 0x15\r\n"
"    Purpose: Reads extended status information\r\n"
"    Response Data:\r\n"
"        Status: 0x00\r\n"
"\r\n"
"[5] Legacy Read Manufacturer/Device ID\r\n"
"    Command: 0x90\r\n"
"    Purpose: Alternative method to read chip identification\r\n"
"    Response Data:\r\n"
"        Byte 0: 0x00\r\n"
"        Byte 1: 0x00\r\n"
"\r\n"
"[6] Read Electronic Signature\r\n"
"    Command: 0xAB\r\n"
"    Purpose: Retrieves the electronic signature (device ID)\r\n"
"    Response Data:\r\n"
"        Signature: 0x41\r\n"
"\r\n"
"[7] Read Unique ID (64-bit)\r\n"
"    Command: 0x4B\r\n"
"    Purpose: Reads the factory-programmed 64-bit unique serial number\r\n"
"    Response Data (8 bytes):\r\n"
"        0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\r\n"
"\r\n"
"[8] Read SFDP Table Headers\r\n"
"    Command: 0x5A\r\n"
"    Purpose: Serial Flash Discoverable Parameters - describes flash capabilities\r\n"
"    Response Data (8 bytes):\r\n"
"        0x53 0x46 0x44 0x50 0x06 0x01 0x02 0xFF\r\n"
"        (ASCII: 'SFDP' + version info)\r\n"
"\r\n"
"[9] SFDP Parameter Headers\r\n"
"    Command: 0x5A\r\n"
"    Purpose: Extended SFDP parameter table information\r\n"
"    Response Data (24 bytes):\r\n"
"        0x53 0x46 0x44 0x50 0x06 0x01 0x02 0xFF\r\n"
"        0x00 0x06 0x01 0x10 0x30 0x00 0x00 0xFF\r\n"
"        0x81 0x00 0x01 0x06 0x00 0x01 0x00 0xFF\r\n"
"\r\n"
"================================================================================\r\n"
"                                 END OF LOG                                    \r\n"
"================================================================================\r\n"
"Generated by: Raspberry Pi Pico W Flash Log Tool\r\n"
"Date Format: 2025-11-04\r\n"
"Log Format Version: 1.0\r\n"
"================================================================================\r\n";

// Helper functions
float get_internal_temperature(void) {
    adc_select_input(ADC_TEMP_CHANNEL);
    uint16_t raw = adc_read();
    float voltage = raw * ADC_CONVERSION_FACTOR;
    float temp = 27.0f - (voltage - 0.706f) / 0.001721f;
    return temp;
}

float get_supply_voltage(void) {
    adc_select_input(3);
    uint16_t raw = adc_read();
    float voltage = raw * ADC_CONVERSION_FACTOR * ADC_VOLTAGE_DIVIDER;
    return voltage;
}

void clear_input_buffer(void) {
    int c;
    do {
        c = getchar_timeout_us(10000);
    } while (c != PICO_ERROR_TIMEOUT);
}

char get_char(void) {
    int c;
    do {
        c = getchar_timeout_us(5000000);
        if (c == PICO_ERROR_TIMEOUT) {
            continue;
        }
        if (c != '\r' && c != '\n' && c != ' ') {
            sleep_ms(50);
            int extra;
            do {
                extra = getchar_timeout_us(10000);
            } while (extra != PICO_ERROR_TIMEOUT);
            return (char)c;
        }
    } while (1);
}

bool wait_for_button_press(void) {
    static bool last_state = true;
    static uint32_t last_time = 0;
    
    bool current_state = gpio_get(BUTTON_PIN);
    uint32_t current_time = to_ms_since_boot(get_absolute_time());
    
    if (last_state && !current_state && (current_time - last_time) > DEBOUNCE_DELAY_MS) {
        last_time = current_time;
        last_state = current_state;
        return true;
    }
    
    last_state = current_state;
    return false;
}

void show_main_menu(void) {
    printf("\n");
    printf("================ MAIN MENU ================\n");
    printf("  1. Generate a dummy file to insert into SD card\n");
    printf("  2. Show system status (temp / voltage)\n");
    printf("  3. Reboot (re-run SD initialisation)\n");
    printf("  q) Quit program\n");
    printf("===========================================\n");
    printf("Select option: ");
    fflush(stdout);
}

bool sd_init_and_mount(void) {
    printf("\nSD card initialisation...\n");
    
    sd_card_initialized = sd_card_init();
    if (!sd_card_initialized) {
        printf("  - Hardware: FAILED\n");
        return false;
    }
    printf("  - Hardware: OK\n");
    
    sd_card_mounted = sd_mount();
    if (!sd_card_mounted) {
        printf("  - Filesystem: FAILED\n");
        return false;
    }
    printf("  - Filesystem: FAT32 mounted\n");
    printf("SD CARD MOUNTED SUCCESSFULLY ✅\n");
    
    return true;
}

void handle_generate_json(void) {
    printf("\n=== Generate Dummy JSON Log File ===\n");
    
    // Show preview
    printf("\n--- Preview: spi_flash_log_001.txt (first 400 chars) ---\n");
    int preview_len = strlen(generated_json);
    if (preview_len > 400) preview_len = 400;
    
    for (int i = 0; i < preview_len; i++) {
        putchar(generated_json[i]);
    }
    if (strlen(generated_json) > 400) {
        printf("...\n");
    }
    printf("\n--- End of preview ---\n");
    printf("Total size: %d bytes\n", (int)strlen(generated_json));
    
    printf("\nSave this file to SD card as TXT format? (y/n): ");
    fflush(stdout);
    
    char confirm = get_char();
    printf("%c\n", confirm);
    
    if (confirm != 'y' && confirm != 'Y') {
        printf("Operation cancelled.\n");
        sleep_ms(1000);
        current_state = MAIN_MENU;
        return;
    }
    
    // Write to SD card as TXT file (8.3 format: max 8 chars + 3 extension)
    const char *filename = "FLASHLOG.TXT";
    printf("\nWriting JSON content to SD card as TXT file...\n");
    printf("Filename: %s\n", filename);
    
    bool success = sd_write_file(filename, generated_json);
    
    if (!success) {
        printf("\n❌ Error: Failed to write file to SD card\n");
        printf("Possible reasons:\n");
        printf("  - SD card is full\n");
        printf("  - SD card is write-protected\n");
        printf("  - Filesystem error\n");
        printf("\nPress 1 to return to main menu.\n");
        while (get_char() != '1');
        current_state = MAIN_MENU;
        return;
    }
    
    // Verify file exists
    sleep_ms(100);
    if (!sd_file_exists(filename)) {
        printf("\n⚠️  Warning: File write reported success but verification failed\n");
        printf("Press 1 to return to main menu.\n");
        while (get_char() != '1');
        current_state = MAIN_MENU;
        return;
    }
    
    // Success!
    printf("\n✅ File successfully saved to SD card!\n");
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("Filename : %s\n", filename);
    printf("Format   : TXT (plain text with JSON content)\n");
    printf("Size     : %d bytes\n", (int)strlen(generated_json));
    printf("Location : Root directory of SD card\n");
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    
    printf("\nPress 1 to return to main menu.\n");
    while (get_char() != '1');
    current_state = MAIN_MENU;
}

void handle_show_system_status(void) {
    printf("\n=== System Status ===\n");
    
    float temp = get_internal_temperature();
    float voltage = get_supply_voltage();
    
    printf("Temperature : %.1f °C\n", temp);
    printf("Voltage     : %.2f V\n", voltage);
    printf("SD mounted  : %s\n", sd_card_mounted ? "YES ✅" : "NO ❌");
    
    if (sd_card_mounted) {
        printf("SD status   : Ready for read/write operations\n");
    } else {
        printf("SD status   : Not available (use option 3 to initialize)\n");
    }
    
    printf("\nPress 1 to return to main menu.\n");
    while (get_char() != '1');
    current_state = MAIN_MENU;
}

void handle_reboot_tool(void) {
    printf("\n=== Rebooting Tool ===\n");
    printf("Unmounting SD card...\n");
    
    if (sd_card_mounted) {
        sd_unmount();
    }
    
    printf("Resetting system state...\n");
    sd_card_initialized = false;
    sd_card_mounted = false;
    
    printf("System reset complete.\n");
    current_state = BOOT_WAIT_FOR_BUTTON;
    printf("\nWaiting for GP20 button press to begin...\n");
}

int main(void) {
    stdio_init_all();
    sleep_ms(2000);
    
    // Initialize ADC
    adc_init();
    adc_gpio_init(ADC_VSYS_PIN);
    adc_set_temp_sensor_enabled(true);
    
    // Initialize button
    gpio_init(BUTTON_PIN);
    gpio_set_dir(BUTTON_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_PIN);
    
    printf("\n");
    printf("════════════════════════════════════════\n");
    printf("  Pico Flash → SD JSON Log Tool\n");
    printf("════════════════════════════════════════\n");
    printf("Waiting for GP20 button press to begin...\n");
    
    while (true) {
        switch (current_state) {
            case BOOT_WAIT_FOR_BUTTON:
                if (wait_for_button_press()) {
                    printf("\n🔘 GP20 pressed!\n");
                    sleep_ms(100);
                    clear_input_buffer();
                    current_state = SD_CHECK;
                }
                sleep_ms(10);
                break;
                
            case SD_CHECK: {
                printf("\nIs an SD card inserted in the slot? (y/n): ");
                fflush(stdout);
                
                char response = get_char();
                printf("%c\n", response);
                
                if (response == 'n' || response == 'N') {
                    printf("Please insert a FAT32 SD card and press GP20 again to retry.\n");
                    sd_card_initialized = false;
                    sd_card_mounted = false;
                    current_state = BOOT_WAIT_FOR_BUTTON;
                } else if (response == 'y' || response == 'Y') {
                    if (sd_init_and_mount()) {
                        current_state = MAIN_MENU;
                    } else {
                        printf("\n❌ SD card initialisation failed\n");
                        printf("Check:\n");
                        printf("  - Card is inserted correctly\n");
                        printf("  - Card is FAT32 formatted\n");
                        printf("  - Card is not write-protected\n");
                        printf("\nPress GP20 to try again...\n");
                        sd_card_initialized = false;
                        sd_card_mounted = false;
                        current_state = BOOT_WAIT_FOR_BUTTON;
                    }
                } else {
                    printf("Invalid input. Please enter 'y' or 'n'.\n");
                }
                break;
            }
                
            case MAIN_MENU: {
                show_main_menu();
                char choice = get_char();
                printf("%c\n", choice);
                
                // Check SD card status for option 1
                if (choice == '1' && !sd_card_mounted) {
                    printf("\n❌ SD card not mounted\n");
                    printf("Please use option 3 to re-initialise.\n");
                    sleep_ms(2000);
                    break;
                }
                
                switch (choice) {
                    case '1':
                        current_state = GENERATE_JSON;
                        break;
                    case '2':
                        handle_show_system_status();
                        break;
                    case '3':
                        handle_reboot_tool();
                        break;
                    case 'q':
                    case 'Q':
                        current_state = QUIT;
                        break;
                    default:
                        printf("Invalid selection. Please try again.\n");
                        sleep_ms(1000);
                        break;
                }
                break;
            }
                
            case GENERATE_JSON:
                handle_generate_json();
                break;
                
            case QUIT:
                printf("\n════════════════════════════════════════\n");
                printf("  Program halted\n");
                printf("  Reset the Pico to start again\n");
                printf("════════════════════════════════════════\n");
                while (true) {
                    tight_loop_contents();
                }
                break;
                
            default:
                current_state = BOOT_WAIT_FOR_BUTTON;
                break;
        }
    }
    
    return 0;
}